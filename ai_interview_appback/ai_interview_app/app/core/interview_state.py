# app/core/interview_state.py - Defines the state object for an interview session

from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field, ConfigDict # Using Pydantic for state structure and potential serialization
from fastapi import WebSocket

# Using Pydantic for data structure definition, though this is an internal state representation
class InterviewState(BaseModel):
    """
    Represents the mutable state of a single interview session.
    Stored in memory or a persistent store for active interviews.
    """
    model_config = ConfigDict(arbitrary_types_allowed=True)

    id: str = Field(..., description="Unique identifier for the interview session.")
    job_description_id: str
    resume_id: str
    interview_plan: Dict[str, Any] = Field({}, description="Structured plan/topics derived from pre-analysis.")

    # --- Conversation State ---
    transcript: str = Field("", description="Full accumulated transcript of the interview.")
    conversation_history: List[Dict[str, Any]] = Field([], description="History of turns for LLM context.")
    # Example format: [{'role': 'user', 'content': '...'}, {'role': 'assistant', 'content': '...'}]

    # --- Real-time Processing State ---
    # Buffer for accumulating transcription chunks while user is speaking
    current_chunk_buffer: str = Field("", description="Buffer for transcription chunks between pauses.")
    # Store the latest draft generated by the incremental LLM task
    latest_llm_draft: str = Field("", description="Latest non-final response draft from incremental processing.")

    # --- Connection State ---
    # Store the active WebSocket connection object if in memory
    # Note: WebSocket object is NOT serializable, so this is only for in-memory state.
    # If using a distributed state store (Redis, DB), the connection mapping
    # needs to be managed separately (e.g., in the Manager or a dedicated service).
    websocket: Optional[WebSocket] = Field(None, exclude=True) # Exclude from serialization

    # --- Analysis State ---
    # Placeholder for tracking analysis progress or results
    # analysis_status: str = "pending"
    # analysis_results: Optional[Dict[str, Any]] = None

    # --- Methods to update state ---
    def add_chunk(self, chunk_text: str, is_final: bool, timestamp: float):
        """Appends a new transcription chunk to the buffer."""
        # Simple concatenation. More advanced handling might be needed (e.g., punctuation, re-segmentation)
        # For incremental chunks, just add to buffer.
        # If is_final is True, the buffer holds the full utterance, which is then processed.
        self.current_chunk_buffer += chunk_text + (" " if not is_final else "") # Add space between chunks if not final

        # Note: The transcript is updated with full turns after a final response is received.

    def clear_chunk_buffer(self):
        """Resets the transcription chunk buffer."""
        self.current_chunk_buffer = ""

    # Method to send message via associated websocket (only works if websocket is stored)
    async def send_message(self, message: str):
        """Sends a message through the active WebSocket connection if available."""
        if self.websocket:
            try:
                await self.websocket.send_text(message)
            except Exception as e:
                 print(f"Error sending message via websocket for interview {self.id}: {e}")
                 # Handle disconnection? The websocket endpoint should also catch this.
                 self.websocket = None # Clear the reference if sending fails

    # Helper method to get state as dict (excluding non-serializable parts)
    def to_dict(self):
         return self.model_dump(exclude={"websocket"})